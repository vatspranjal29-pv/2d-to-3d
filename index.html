<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>2D → 3D Layout Demo</title>
  <style>
    body { font-family: system-ui, Arial, sans-serif; margin:0; display:flex; height:100vh; }
    #ui { width:360px; padding:16px; box-sizing:border-box; background:#f7f7f7; border-right:1px solid #e0e0e0; }
    #viewer { flex:1; }
    label{display:block;margin-bottom:8px;font-weight:600}
    button{padding:8px 12px;margin-right:8px}
    canvas#sourceCanvas{display:none}
    .small{font-size:13px;color:#555}
  </style>
</head>
<body>
  <div id="ui">
    <h2>2D → 3D Layout Demo</h2>
    <p class="small">Upload a 2D floor-plan or sketch. This demo builds a simple heightmap-based 3D mesh from the image brightness (proof-of-concept). For production you'll replace this with an AI/BIM backend.</p>

    <label for="file">Choose image (floor plan / sketch)</label>
    <input id="file" type="file" accept="image/*">

    <div style="margin-top:12px">
      <label>Processing options</label>
      <div style="margin-bottom:8px">
        <label class="small">Mesh resolution (lower = faster)</label>
        <input id="resolution" type="range" min="32" max="512" value="128">
      </div>
      <div style="margin-bottom:8px">
        <label class="small">Height scale</label>
        <input id="height" type="range" min="0" max="200" value="60">
      </div>
    </div>

    <div style="margin-top:12px">
      <button id="processBtn">Process → Build 3D</button>
      <button id="resetBtn">Reset</button>
    </div>

    <p id="status" class="small">Status: waiting for image</p>
    <hr>
    <p class="small">Usage notes:</p>
    <ul class="small">
      <li>Use clear black/white sketches or floorplans for best result.</li>
      <li>This demo uses image brightness to create heights — not actual BIM conversion.</li>
      <li>Save the resulting view using your browser's screenshot or right-click.</li>
    </ul>
  </div>

  <div id="viewer"></div>

  <!-- hidden canvas for image processing -->
  <canvas id="sourceCanvas"></canvas>

  <!-- three.js (r125-ish) and OrbitControls via unpkg CDN -->
  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.152.2/examples/js/controls/OrbitControls.js"></script>

  <script>
  // Basic client-side demo: convert image brightness -> heightmap -> 3D mesh

  const fileInput = document.getElementById('file');
  const processBtn = document.getElementById('processBtn');
  const resetBtn = document.getElementById('resetBtn');
  const status = document.getElementById('status');
  const resInput = document.getElementById('resolution');
  const heightInput = document.getElementById('height');
  const sourceCanvas = document.getElementById('sourceCanvas');

  let img = new Image();
  let imgLoaded = false;
  let currentTexture = null;

  fileInput.addEventListener('change', (e)=>{
    const f = e.target.files[0];
    if(!f) return;
    const url = URL.createObjectURL(f);
    img.onload = ()=>{ imgLoaded = true; status.textContent = 'Status: image loaded'; URL.revokeObjectURL(url); }
    img.src = url;
  });

  processBtn.addEventListener('click', ()=>{
    if(!imgLoaded){ alert('Please choose an image first'); return; }
    buildHeightmapMesh();
  });

  resetBtn.addEventListener('click', ()=>{ resetScene(); status.textContent='Status: reset'; });

  // --- Three.js scene setup ---
  const container = document.getElementById('viewer');
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xf0f0f0);
  const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 2000);
  camera.position.set(0, 200, 300);
  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(container.clientWidth, container.clientHeight);
  container.appendChild(renderer.domElement);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.target.set(0,0,0);
  controls.update();

  const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
  hemi.position.set(0,200,0);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.6);
  dir.position.set(-100,200,100);
  scene.add(dir);

  // ground helper
  const grid = new THREE.GridHelper(1000, 40, 0x999999, 0xdddddd);
  grid.position.y = -0.1;
  scene.add(grid);

  // dynamic mesh holder
  let meshGroup = new THREE.Group();
  scene.add(meshGroup);

  // handle resize
  window.addEventListener('resize', ()=>{
    camera.aspect = container.clientWidth / container.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(container.clientWidth, container.clientHeight);
  });

  function resetScene(){
    while(meshGroup.children.length) meshGroup.remove(meshGroup.children[0]);
    if(currentTexture){ currentTexture.dispose(); currentTexture=null; }
  }

  function buildHeightmapMesh(){
    status.textContent = 'Status: processing image → generating mesh';
    const targetRes = parseInt(resInput.value, 10); // e.g., 128
    const heightScale = parseFloat(heightInput.value);

    // draw image into canvas resizing to square-ish grid based on resolution
    const w = targetRes;
    const aspect = img.width / img.height;
    const h = Math.max(1, Math.round(w / aspect));
    sourceCanvas.width = w;
    sourceCanvas.height = h;
    const ctx = sourceCanvas.getContext('2d');
    // fill white then draw image fit
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,w,h);
    ctx.drawImage(img, 0, 0, w, h);

    const imgData = ctx.getImageData(0,0,w,h).data;

    // compute height values from brightness
    const heights = new Float32Array(w * h);
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const i = (y*w + x) * 4;
        const r = imgData[i], g = imgData[i+1], b = imgData[i+2];
        const brightness = (0.299*r + 0.587*g + 0.114*b) / 255; // 0..1
        // invert so dark lines (floorplan) become elevated walls if desired
        const inv = 1 - brightness;
        heights[y*w + x] = inv * heightScale; // scale
      }
    }

    // create plane geometry and displace vertices
    resetScene();

    const geometry = new THREE.PlaneGeometry( Math.max(w,h), Math.max(w,h) , w-1, h-1 );
    geometry.rotateX(-Math.PI/2);

    // iterate vertices and set height from heights[]
    const pos = geometry.attributes.position;
    const verts = pos.array;
    for(let i=0;i<pos.count;i++){
      // position layout: x,z,y after rotation; we need to map vertex grid to heights
      const xi = i % w;
      const yi = Math.floor(i / w);
      const hval = heights[ yi * w + xi ];
      verts[i*3 + 1] = hval; // Y axis up because rotated
    }
    geometry.computeVertexNormals();

    // create texture from original canvas for visual
    const tex = new THREE.CanvasTexture(sourceCanvas);
    tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
    currentTexture = tex;

    const mat = new THREE.MeshStandardMaterial({ map: tex, metalness:0.1, roughness:0.9, side:THREE.DoubleSide });
    const mesh = new THREE.Mesh(geometry, mat);
    mesh.position.y = 0;
    meshGroup.add(mesh);

    // add a subtle wall highlight by extruding high pixels into thin boxes (optional)
    const wallGroup = new THREE.Group();
    const threshold = 0.45; // values above this will be considered 'wall'
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const val = heights[y*w + x] / heightScale;
        if(val > threshold){
          const box = new THREE.Mesh(new THREE.BoxGeometry(1, heights[y*w+x],1), new THREE.MeshStandardMaterial({color:0x333333}));
          box.position.set(x - w/2 + 0.5, heights[y*w+x]/2, y - h/2 + 0.5);
          wallGroup.add(box);
        }
      }
    }
    wallGroup.scale.set( (Math.max(w,h)/w), 1, (Math.max(w,h)/h) );
    meshGroup.add(wallGroup);

    // center and scale the whole group to comfortable view
    meshGroup.scale.set(1.0,1.0,1.0);
    meshGroup.position.set(0,0,0);

    status.textContent = 'Status: mesh generated — rotate and inspect (use mouse).';
  }

  // basic animation loop
  function animate(){
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
  }
  animate();

  </script>
</body>
</html>
